defmodule AshPhoenixTranslations.GraphqlExtensions do
  @moduledoc """
  Generates Absinthe schema extensions for translatable Ash resources.

  This module provides utilities to automatically generate GraphQL field extensions
  for resources that use AshPhoenixTranslations. It uses Absinthe's `extend object`
  mechanism to add translation fields to existing GraphQL types.

  ## Usage

  ### Option 1: Generate Extension Module (Recommended)

  Use the Mix task to generate an extension module:

      mix ash_phoenix_translations.gen.graphql_extensions

  This creates a module like:

      defmodule MyApp.Schema.TranslationExtensions do
        use Absinthe.Schema.Notation

        extend object(:product) do
          field :name_translation, :string do
            arg :locale, non_null(:locale_scalar)
            resolve &AshPhoenixTranslations.Graphql.resolve_translation/3
          end
        end
      end

  Then import it in your schema:

      defmodule MyApp.Schema do
        use Absinthe.Schema
        import_type_extensions MyApp.Schema.TranslationExtensions
      end

  ### Option 2: Programmatic Generation

  Generate extension code programmatically:

      domains = [MyApp.Catalog, MyApp.Shop]
      extension_code = AshPhoenixTranslations.GraphqlExtensions.generate(domains)

  ## How It Works

  1. Introspects all resources in the provided domains
  2. Identifies resources with `graphql_translations true` configuration
  3. For each translatable attribute, generates:
     - `<field>_translation` field (singular) with locale argument
     - `<field>_translations` field (plural) returning all translations
  4. Generates shared type definitions (`:locale_scalar`, `:translation`)

  """

  alias AshPhoenixTranslations.Info

  @doc """
  Generates Absinthe schema extension code for all translatable resources in domains.

  Returns an AST that can be used in Absinthe schema modules.

  ## Parameters

  - `domains` - List of Ash domain modules to introspect

  ## Returns

  Returns a string containing the generated Elixir code for the extension module.

  ## Examples

      domains = [MyApp.Catalog]
      code = AshPhoenixTranslations.GraphqlExtensions.generate(domains)
      IO.puts(code)
      # => Full extension module code

  """
  def generate(domains) when is_list(domains) do
    resources = get_translatable_resources(domains)

    """
    defmodule TranslationExtensions do
      @moduledoc \"\"\"
      Auto-generated GraphQL schema extensions for translatable resources.

      Generated by AshPhoenixTranslations.

      To use this module, import it in your Absinthe schema:

          defmodule MyApp.Schema do
            use Absinthe.Schema
            import_type_extensions TranslationExtensions
          end
      \"\"\"

      use Absinthe.Schema.Notation

    #{generate_shared_types()}

    #{Enum.map_join(resources, "\n", &generate_resource_extension/1)}
    end
    """
  end

  @doc """
  Gets all resources with translations from the given domains.

  ## Parameters

  - `domains` - List of Ash domain modules

  ## Returns

  List of resource modules that have translatable attributes.
  """
  def get_translatable_resources(domains) when is_list(domains) do
    domains
    |> Enum.flat_map(&get_domain_resources/1)
    |> Enum.filter(&has_translations?/1)
    |> Enum.filter(&has_graphql_extension?/1)
  end

  defp get_domain_resources(domain) do
    try do
      domain.resources()
    rescue
      _ -> []
    end
  end

  defp has_translations?(resource) do
    try do
      translatable_attrs = Info.translatable_attributes(resource)
      not Enum.empty?(translatable_attrs)
    rescue
      _ -> false
    end
  end

  defp has_graphql_extension?(resource) do
    try do
      extensions = Spark.Dsl.Extension.get_persisted(resource, :extensions, [])

      if Code.ensure_loaded?(AshGraphql.Resource) do
        AshGraphql.Resource in extensions
      else
        false
      end
    rescue
      _ -> false
    end
  end

  @doc """
  Generates shared type definitions for locale and translation types.
  """
  def generate_shared_types do
    """
      # Shared locale scalar type
      scalar :locale_scalar do
        parse &AshPhoenixTranslations.Graphql.parse_locale/1
        serialize &AshPhoenixTranslations.Graphql.serialize_locale/1
      end

      # Translation object type for returning all translations
      object :translation do
        field :locale, non_null(:string)
        field :value, :string
      end
    """
  end

  @doc """
  Generates extension code for a single resource.

  ## Parameters

  - `resource` - Ash resource module

  ## Returns

  String containing the `extend object` block for the resource.
  """
  def generate_resource_extension(resource) do
    translatable_attrs = Info.translatable_attributes(resource)
    graphql_type = get_graphql_type(resource)

    fields =
      translatable_attrs
      |> Enum.map(&generate_field_extensions/1)
      |> Enum.join("\n")

    """
      # Extensions for #{inspect(resource)}
      extend object(:#{graphql_type}) do
    #{fields}
      end
    """
  end

  defp get_graphql_type(resource) do
    try do
      if Code.ensure_loaded?(AshGraphql.Resource) do
        # Try to get the GraphQL type from AshGraphql configuration
        case AshGraphql.Resource.Info.type(resource) do
          nil ->
            # Fall back to resource name
            resource
            |> Module.split()
            |> List.last()
            |> Macro.underscore()
            |> String.to_atom()

          type ->
            type
        end
      else
        # Fall back to resource name if AshGraphql not loaded
        resource
        |> Module.split()
        |> List.last()
        |> Macro.underscore()
        |> String.to_atom()
      end
    rescue
      _ ->
        resource
        |> Module.split()
        |> List.last()
        |> Macro.underscore()
        |> String.to_atom()
    end
  end

  defp generate_field_extensions(attr) do
    field_name = attr.name
    type = graphql_type_for_ash_type(attr.type)

    """
        # Singular translation field with locale argument
        field :#{field_name}_translation, :#{type} do
          arg :locale, non_null(:locale_scalar)
          resolve fn resource, args, resolution ->
            AshPhoenixTranslations.Graphql.resolve_translation(
              resource,
              args,
              Map.put(resolution, :state, :#{field_name})
            )
          end
        end

        # All translations for this field
        field :#{field_name}_translations, list_of(:translation) do
          resolve fn resource, args, resolution ->
            AshPhoenixTranslations.Graphql.resolve_all_translations(
              resource,
              args,
              Map.put(resolution, :state, :#{field_name})
            )
          end
        end
    """
  end

  defp graphql_type_for_ash_type(:string), do: :string
  defp graphql_type_for_ash_type(:text), do: :string
  defp graphql_type_for_ash_type(:integer), do: :integer
  defp graphql_type_for_ash_type(:boolean), do: :boolean
  defp graphql_type_for_ash_type(:decimal), do: :float
  defp graphql_type_for_ash_type(:float), do: :float
  defp graphql_type_for_ash_type(:date), do: :date
  defp graphql_type_for_ash_type(:datetime), do: :datetime
  defp graphql_type_for_ash_type(_), do: :string
end
